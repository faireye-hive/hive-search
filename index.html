<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HiveSense Search ‚Äî Demo</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.5/dist/purify.min.js"></script>
  <style>
    .loading-spinner {
      border: 3px solid #f3f3f3;
      border-top: 3px solid #334155;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .sort-btn.active {
      background-color: #334155;
      color: white;
    }
    
    .progress-bar {
      height: 4px;
      background-color: #e2e8f0;
      border-radius: 2px;
      overflow: hidden;
      margin-top: 8px;
    }
    
    .progress-fill {
      height: 100%;
      background-color: #3b82f6;
      transition: width 0.3s ease;
    }
    
    .filter-badge {
      animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-5px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .similar-post-badge {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
  </style>
</head>
<body class="bg-slate-50 text-slate-800 min-h-screen">
  <div class="max-w-6xl mx-auto p-4 md:p-6">
    <header class="mb-6">
      <h1 class="text-3xl font-extrabold">HiveSense Search</h1>
      <p class="text-sm text-slate-600">
        Advanced search with filters and link search (shows similar posts)
      </p>
    </header>

    <section class="bg-white p-6 rounded-2xl shadow-md mb-6">
      <form id="searchForm" class="grid grid-cols-1 md:grid-cols-8 gap-3 items-center">
        <input id="q" class="md:col-span-4 p-3 rounded-lg border border-slate-200 focus:outline-none focus:ring-2 focus:ring-slate-300" 
               placeholder="Ex: @sm-silva anime +life -comics or post URL" value="bitcoin price news" />
        
        <select id="truncate" class="p-3 rounded-lg border border-slate-200" title="truncate"> 
          <option value="0">Sem truncar</option>
          <option value="100">truncate=100</option>
          <option value="200" selected>truncate=200</option>
          <option value="500">truncate=500</option>
        </select>
        
        <!-- Bot√µes de ordena√ß√£o -->
        <div id="sortButtons" class="flex rounded-lg border border-slate-200 overflow-hidden md:col-span-1">
          <button type="button" id="sortRelevance" class="sort-btn active flex-1 p-3 text-sm bg-slate-100 hover:bg-slate-200 transition-colors" title="Sort by relevance">
            üîç
          </button>
          <button type="button" id="sortRecent" class="sort-btn flex-1 p-3 text-sm bg-slate-100 hover:bg-slate-200 transition-colors" title="Sort by newest">
            ‚è∞
          </button>
        </div>
        
        <button id="btnSearch" type="submit" 
                class="md:col-span-1 bg-slate-800 text-white p-3 rounded-lg hover:opacity-90 flex justify-center items-center">
          <span id="btnText">Buscar</span>
          <div id="btnSpinner" class="loading-spinner hidden ml-2"></div>
        </button>
      </form>

      <!-- Filtros ativos -->
      <div id="activeFilters" class="mt-4 hidden">
        <div class="flex flex-wrap gap-2 items-center">
          <span class="text-sm text-slate-600">Filtros ativos:</span>
          <div id="filterBadges" class="flex flex-wrap gap-2"></div>
          <button id="clearFilters" class="text-sm text-red-600 hover:text-red-800 ml-2">
            Limpar filtros
          </button>
        </div>
      </div>

      <div id="meta" class="mt-4 text-sm text-slate-500"></div>
      <div id="progressContainer" class="hidden">
        <div class="progress-bar">
          <div id="progressFill" class="progress-fill" style="width: 0%"></div>
        </div>
        <div id="progressText" class="text-xs text-slate-500 mt-1"></div>
      </div>

      <!-- Info do post original (para busca por link) -->
      <div id="originalPostInfo" class="mt-4 hidden">
        <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
          <div class="flex items-center justify-between">
            <div>
              <h3 class="font-semibold text-blue-800">Posts similares a:</h3>
              <div id="originalPostDetails" class="text-sm text-blue-600 mt-1"></div>
            </div>
            <button id="closeOriginalPostInfo" class="text-blue-500 hover:text-blue-700">
              ‚úï
            </button>
          </div>
        </div>
      </div>

      <div id="results" class="mt-4 space-y-4"></div>

      <!-- Pagina√ß√£o -->
      <div id="pagination" class="mt-6 pt-4 border-t border-slate-200 hidden">
        <div class="flex flex-wrap justify-between items-center">
          <div class="text-sm text-slate-600 mb-2 md:mb-0" id="pageInfo"></div>
          <div class="flex space-x-2">
            <button id="prevPage" class="px-4 py-2 bg-slate-100 text-slate-700 rounded-lg hover:bg-slate-200 disabled:opacity-50 disabled:cursor-not-allowed">
              ‚Üê Previous
            </button>
            <div class="flex items-center space-x-1" id="pageNumbers"></div>
            <button id="nextPage" class="px-4 py-2 bg-slate-100 text-slate-700 rounded-lg hover:bg-slate-200 disabled:opacity-50 disabled:cursor-not-allowed">
              Next ‚Üí
            </button>
          </div>
        </div>
      </div>
    </section>

    <footer class="mt-6 text-xs text-slate-500">
      <div class="mb-2">
        <strong>Search syntax:</strong>
        <ul class="list-disc pl-5 mt-1 space-y-1">
          <li><code>@username</code> ‚Üí Show only posts from this author.</li>
          <li><code>+word</code> ‚Üí Includes only posts with this tag/category.</li>
          <li><code>-word</code> ‚Üí Exclude posts with this tag/category</li>
          <li><code>Post URL</code> ‚Üí Show posts similar to the linked post.</li>
          <li>Example URLs: hive.blog, ecency.com, peakd.com</li>
        </ul>
      </div>
      Using the HiveSense API ‚Ä¢ Batch search of 50 posts ‚Ä¢ Similar posts
    </footer>
  </div>

  <script>
    // Configura√ß√µes
    const API_BASE = "https://api.syncad.com/hivesense-api/posts/search";
    const API_POSTS_BY_IDS = "https://api.hive.blog/hivesense-api/posts/by-ids";
    const API_SIMILAR_POSTS = "https://api.hive.blog/hivesense-api/posts";
    const POSTS_PER_PAGE = 10;
    const MAX_RESULTS = 1000;
    const BATCH_SIZE = 50;

    // Estado global
    let currentSearch = {
      query: "",
      truncate: 200,
      sortOrder: "relevance",
      allPosts: [], // Todos os posts carregados
      filteredPosts: [], // Posts ap√≥s aplicar filtros
      currentPage: 1,
      totalResults: 0,
      isFetchingComplete: false,
      originalSearchResults: [],
      filters: {
        authors: [], // Autores com @ (mostrar APENAS esses)
        includeTerms: [], // Termos com + (DEVE ter)
        excludeTerms: [], // Termos com - (N√ÉO PODE ter)
      },
      cleanQuery: "", // Query sem filtros
      searchMode: "normal", // 'normal' ou 'similar'
      originalPost: null, // Informa√ß√µes do post original (para busca por link)
      similarPostsStubs: [] // Stubs dos posts similares (para ordena√ß√£o)
    };

    // Elementos DOM
    const elements = {
      searchForm: document.getElementById("searchForm"),
      searchInput: document.getElementById("q"),
      truncateSelect: document.getElementById("truncate"),
      resultsEl: document.getElementById("results"),
      metaEl: document.getElementById("meta"),
      paginationEl: document.getElementById("pagination"),
      prevBtn: document.getElementById("prevPage"),
      nextBtn: document.getElementById("nextPage"),
      pageInfo: document.getElementById("pageInfo"),
      pageNumbers: document.getElementById("pageNumbers"),
      btnSpinner: document.getElementById("btnSpinner"),
      btnText: document.getElementById("btnText"),
      sortRelevance: document.getElementById("sortRelevance"),
      sortRecent: document.getElementById("sortRecent"),
      progressContainer: document.getElementById("progressContainer"),
      progressFill: document.getElementById("progressFill"),
      progressText: document.getElementById("progressText"),
      activeFilters: document.getElementById("activeFilters"),
      filterBadges: document.getElementById("filterBadges"),
      clearFilters: document.getElementById("clearFilters"),
      originalPostInfo: document.getElementById("originalPostInfo"),
      originalPostDetails: document.getElementById("originalPostDetails"),
      closeOriginalPostInfo: document.getElementById("closeOriginalPostInfo"),
    };

    /**
     * Verifica se a string √© uma URL v√°lida do Hive
     */
    function isHiveURL(input) {
      // Padr√µes de URLs do Hive
      const hivePatterns = [
        /^https?:\/\/(?:www\.)?hive\.blog\/(?:[\w-]+\/)?@([\w-]+)\/([\w-]+)/i,
        /^https?:\/\/(?:www\.)?ecency\.com\/@([\w-]+)\/([\w-]+)/i,
        /^https?:\/\/(?:www\.)?peakd\.com\/(?:[\w-]+\/)?@([\w-]+)\/([\w-]+)/i,
        /^https?:\/\/(?:www\.)?leofinance\.io\/@([\w-]+)\/([\w-]+)/i,
        /^https?:\/\/(?:www\.)?splintertalk\.io\/@([\w-]+)\/([\w-]+)/i,
        /^https?:\/\/(?:www\.)?proofofbrain\.io\/@([\w-]+)\/([\w-]+)/i,
        /^https?:\/\/(?:www\.)?liketu\.io\/@([\w-]+)\/([\w-]+)/i,
        /^https?:\/\/(?:www\.)?naturalmedicine\.io\/@([\w-]+)\/([\w-]+)/i,
      ];

      for (const pattern of hivePatterns) {
        const match = input.match(pattern);
        if (match) {
          return {
            isHiveURL: true,
            author: match[1],
            permlink: match[2],
            url: input,
          };
        }
      }

      return { isHiveURL: false };
    }

    /**
     * Extrai autor e permlink de uma URL do Hive
     */
    function extractAuthorAndPermlinkFromURL(url) {
      const urlInfo = isHiveURL(url);
      if (urlInfo.isHiveURL) {
        return {
          author: urlInfo.author,
          permlink: urlInfo.permlink,
        };
      }
      return null;
    }

    /**
     * Busca posts similares
     */
    async function fetchSimilarPosts(author, permlink, truncate = 200) {
      try {
        const url = `${API_SIMILAR_POSTS}/${author}/${permlink}/similar?truncate=${truncate}&result_limit=100&full_posts=10`;

        elements.metaEl.textContent = `Buscando posts similares a @${author}/${permlink}...`;

        const response = await fetch(url);

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        return await response.json();
      } catch (error) {
        console.error("Erro ao buscar posts similares:", error);
        throw error;
      }
    }

    /**
     * Extrai filtros da query
     */
    function extractFiltersFromQuery(query) {
      let cleanQuery = query;
      const filters = {
        authors: [],
        includeTerms: [],
        excludeTerms: [],
      };

      // Extrai autores (@usuario)
      const authorRegex = /@([a-zA-Z0-9.\-_]+)/g;
      let match;
      while ((match = authorRegex.exec(query)) !== null) {
        const author = match[1].toLowerCase();
        if (!filters.authors.includes(author)) {
          filters.authors.push(author);
        }
      }
      cleanQuery = cleanQuery.replace(authorRegex, "");

      // Extrai termos de inclus√£o (+termo)
      const includeRegex = /\+([a-zA-Z0-9.\-_]+)/g;
      while ((match = includeRegex.exec(query)) !== null) {
        const term = match[1].toLowerCase();
        if (!filters.includeTerms.includes(term)) {
          filters.includeTerms.push(term);
        }
      }
      cleanQuery = cleanQuery.replace(includeRegex, "");

      // Extrai termos de exclus√£o (-termo)
      const excludeRegex = /-([a-zA-Z0-9.\-_]+)/g;
      while ((match = excludeRegex.exec(query)) !== null) {
        const term = match[1].toLowerCase();
        if (!filters.excludeTerms.includes(term)) {
          filters.excludeTerms.push(term);
        }
      }
      cleanQuery = cleanQuery.replace(excludeRegex, "");

      // Limpa a query (remove m√∫ltiplos espa√ßos e trim)
      cleanQuery = cleanQuery.replace(/\s+/g, " ").trim();

      return { cleanQuery, filters };
    }

    /**
     * Atualiza a exibi√ß√£o dos filtros ativos
     */
    function updateActiveFiltersDisplay() {
      elements.filterBadges.innerHTML = "";

      let hasFilters = false;

      // Filtros de autor
      currentSearch.filters.authors.forEach((author) => {
        hasFilters = true;
        const badge = document.createElement("span");
        badge.className =
          "filter-badge px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-xs font-medium flex items-center gap-1";
        badge.innerHTML = `@${author} <button class="text-blue-600 hover:text-blue-800 remove-filter" data-type="author" data-value="${author}">√ó</button>`;
        elements.filterBadges.appendChild(badge);
      });

      // Filtros de inclus√£o
      currentSearch.filters.includeTerms.forEach((term) => {
        hasFilters = true;
        const badge = document.createElement("span");
        badge.className =
          "filter-badge px-3 py-1 bg-green-100 text-green-800 rounded-full text-xs font-medium flex items-center gap-1";
        badge.innerHTML = `+${term} <button class="text-green-600 hover:text-green-800 remove-filter" data-type="include" data-value="${term}">√ó</button>`;
        elements.filterBadges.appendChild(badge);
      });

      // Filtros de exclus√£o
      currentSearch.filters.excludeTerms.forEach((term) => {
        hasFilters = true;
        const badge = document.createElement("span");
        badge.className =
          "filter-badge px-3 py-1 bg-red-100 text-red-800 rounded-full text-xs font-medium flex items-center gap-1";
        badge.innerHTML = `-${term} <button class="text-red-600 hover:text-red-800 remove-filter" data-type="exclude" data-value="${term}">√ó</button>`;
        elements.filterBadges.appendChild(badge);
      });

      // Mostra/oculta container de filtros
      if (hasFilters) {
        elements.activeFilters.classList.remove("hidden");
      } else {
        elements.activeFilters.classList.add("hidden");
      }

      // Adiciona event listeners aos bot√µes de remover filtro
      document.querySelectorAll(".remove-filter").forEach((button) => {
        button.addEventListener("click", (e) => {
          e.stopPropagation();
          const type = button.dataset.type;
          const value = button.dataset.value;
          removeFilter(type, value);
        });
      });
    }

    /**
     * Atualiza a exibi√ß√£o do post original (para busca por link)
     */
    function updateOriginalPostInfo() {
      if (currentSearch.originalPost) {
        const post = currentSearch.originalPost;
        elements.originalPostDetails.innerHTML = `
          <div class="font-medium">${escapeHtml(
            post.title || post.permlink
          )}</div>
          <div class="mt-1">por @${escapeHtml(post.author)} ‚Ä¢ ${formatDate(
          post.created
        )}</div>
          <div class="mt-1 flex gap-2">
            <a href="https://hive.blog${
              post.url || `/@${post.author}/${post.permlink}`
            }" 
               target="_blank" 
               class="text-blue-600 hover:text-blue-800 text-xs">
              üîó Ver post original
            </a>
          </div>
        `;
        elements.originalPostInfo.classList.remove("hidden");
      } else {
        elements.originalPostInfo.classList.add("hidden");
      }
    }

    /**
     * Remove um filtro espec√≠fico
     */
    function removeFilter(type, value) {
      switch (type) {
        case "author":
          currentSearch.filters.authors =
            currentSearch.filters.authors.filter((a) => a !== value);
          break;
        case "include":
          currentSearch.filters.includeTerms =
            currentSearch.filters.includeTerms.filter((t) => t !== value);
          break;
        case "exclude":
          currentSearch.filters.excludeTerms =
            currentSearch.filters.excludeTerms.filter((t) => t !== value);
          break;
      }

      // Atualiza o campo de busca
      updateSearchInputFromFilters();
      updateActiveFiltersDisplay();

      // Reaplica os filtros e renderiza
      applyFilters();
      renderCurrentPage();
      updatePagination();
    }

    /**
     * Atualiza o campo de busca com base nos filtros atuais
     */
    function updateSearchInputFromFilters() {
      let query = currentSearch.cleanQuery;

      currentSearch.filters.authors.forEach((author) => {
        query += ` @${author}`;
      });

      currentSearch.filters.includeTerms.forEach((term) => {
        query += ` +${term}`;
      });

      currentSearch.filters.excludeTerms.forEach((term) => {
        query += ` -${term}`;
      });

      elements.searchInput.value = query.trim();
    }

    /**
     * Aplica todos os filtros aos posts
     */
    function applyFilters() {
      let filtered = [...currentSearch.allPosts];

      // 1. Filtro por autor (somente posts desses autores)
      if (currentSearch.filters.authors.length > 0) {
        filtered = filtered.filter((post) => {
          const postAuthor = post.author ? post.author.toLowerCase() : "";
          return currentSearch.filters.authors.some(
            (author) => postAuthor === author
          );
        });
      }

      // 2. Filtro de inclus√£o (+termo) - deve estar na categoria ou tags
      if (currentSearch.filters.includeTerms.length > 0) {
        filtered = filtered.filter((post) => {
          // Verifica categoria
          const category = post.category ? post.category?.toLowerCase() : "";
          const hasCategoryMatch = currentSearch.filters.includeTerms.some(
            (term) => category.includes(term)
          );

          // Verifica tags do json_metadata
          let hasTagMatch = false;
          if (post.json_metadata) {
            try {
              const metadata =
                typeof post.json_metadata === "string"
                  ? JSON.parse(post.json_metadata)
                  : post.json_metadata;

              if (metadata.tags && Array.isArray(metadata.tags)) {
                const tags = metadata.tags.map((tag) => tag?.toLowerCase());
                hasTagMatch = currentSearch.filters.includeTerms.some(
                  (term) => tags?.some((tag) => tag?.includes(term))
                );
              }
            } catch (e) {
              console.error("Erro ao parsear json_metadata:", e);
            }
          }

          return hasCategoryMatch || hasTagMatch;
        });
      }

      // 3. Filtro de exclus√£o (-termo) - n√£o pode estar na categoria nem tags
      if (currentSearch.filters.excludeTerms.length > 0) {
        filtered = filtered.filter((post) => {
          // Verifica categoria
          const category = post.category ? post.category?.toLowerCase() : "";
          const hasCategoryExclusion =
            currentSearch.filters.excludeTerms.some((term) =>
              category.includes(term)
            );

          if (hasCategoryExclusion) return false;

          // Verifica tags do json_metadata
          if (post.json_metadata) {
            try {
              const metadata =
                typeof post.json_metadata === "string"
                  ? JSON.parse(post.json_metadata)
                  : post.json_metadata;

              if (metadata.tags && Array.isArray(metadata.tags)) {
                const tags = metadata.tags.map((tag) => tag?.toLowerCase());
                const hasTagExclusion =
                  currentSearch.filters.excludeTerms.some((term) =>
                    tags?.some((tag) => tag?.includes(term))
                  );

                if (hasTagExclusion) return false;
              }
            } catch (e) {
              console.error("Erro ao parsear json_metadata:", e);
            }
          }

          return true;
        });
      }

      currentSearch.filteredPosts = filtered;
    }

    /**
     * Extrai a primeira imagem de um corpo de texto
     */
    function firstImageFromBody(body) {
      if (!body) return null;

      const md = /!\[[^\]]*\]\((https?:\/\/[^)\s]+)\)/i.exec(body);
      if (md) return md[1];

      const html = /<img[^>]+src=["']([^"']+)["']/i.exec(body);
      if (html) return html[1];

      const url =
        /(https?:\/\/[^\s"'()]+\.(?:png|jpg|jpeg|gif|webp|bmp))/i.exec(body);
      if (url) return url[1];

      return null;
    }

    /**
     * Formata data para exibi√ß√£o
     */
    function formatDate(iso) {
      try {
        const date = new Date(iso);
        const now = new Date();
        const diffMs = now - date;
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
        const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
        const diffMinutes = Math.floor(diffMs / (1000 * 60));

        if (diffMinutes < 60) {
          return `h√° ${diffMinutes} min`;
        } else if (diffHours < 24) {
          return `h√° ${diffHours} h`;
        } else if (diffDays < 30) {
          return `h√° ${diffDays} dias`;
        } else {
          return date.toLocaleDateString("pt-BR", {
            day: "2-digit",
            month: "2-digit",
            year: "numeric",
          });
        }
      } catch (e) {
        return iso;
      }
    }

    /**
     * Formata data completa para tooltip
     */
    function formatFullDate(iso) {
      try {
        const date = new Date(iso);
        return date.toLocaleDateString("pt-BR", {
          day: "2-digit",
          month: "2-digit",
          year: "numeric",
          hour: "2-digit",
          minute: "2-digit",
        });
      } catch (e) {
        return iso;
      }
    }

    /**
     * Escapa HTML para seguran√ßa
     */
    function escapeHtml(str) {
      let str2 = DOMPurify.sanitize(str);
      if (str2 === null || str2 === undefined) return "";
      const div = document.createElement("div");
      div.textContent = String(str2);
      return div.innerHTML;
    }

    /**
     * Formata valores de payout
     */
    function formatPayout(value) {
      if (!value) return "0.000";
      const num = parseFloat(value);
      return isNaN(num) ? "0.000" : num.toFixed(3);
    }

    /**
     * Mostra/oculta spinner no bot√£o
     */
    function setLoading(loading) {
      if (loading) {
        elements.btnSpinner.classList.remove("hidden");
        elements.btnText.textContent = "Buscando...";
        elements.searchForm.querySelector("button").disabled = true;
      } else {
        elements.btnSpinner.classList.add("hidden");
        elements.btnText.textContent = "Buscar";
        elements.searchForm.querySelector("button").disabled = false;
      }
    }

    /**
     * Atualiza os bot√µes de ordena√ß√£o ativos
     */
    function updateSortButtons() {
      document.querySelectorAll(".sort-btn").forEach((btn) => {
        btn.classList.remove("active");
      });

      if (currentSearch.sortOrder === "relevance") {
        elements.sortRelevance.classList.add("active");
      } else {
        elements.sortRecent.classList.add("active");
      }
    }

    /**
     * Ordena os posts conforme a ordem selecionada
     */
    function sortPosts(posts) {
      if (currentSearch.sortOrder === "recent") {
        return [...posts].sort((a, b) => {
          const dateA = a.created ? new Date(a.created).getTime() : 0;
          const dateB = b.created ? new Date(b.created).getTime() : 0;
          return dateB - dateA;
        });
      } else {
        // Se for modo similar, mant√©m a ordem original da API de similares
        if (currentSearch.searchMode === "similar") {
          // Para manter a ordem de relev√¢ncia dos similares, precisamos ordenar
          // pelos stubs na ordem que vieram da API
          const orderMap = new Map();
          currentSearch.similarPostsStubs.forEach((stub, index) => {
            orderMap.set(`${stub.author}/${stub.permlink}`, index);
          });

          return [...posts].sort((a, b) => {
            const keyA = `${a.author}/${a.permlink}`;
            const keyB = `${b.author}/${b.permlink}`;
            const indexA = orderMap.get(keyA) ?? Infinity;
            const indexB = orderMap.get(keyB) ?? Infinity;
            return indexA - indexB;
          });
        } else {
          // Para busca normal, usa a ordem de relev√¢ncia da busca
          const orderMap = new Map();
          currentSearch.originalSearchResults.forEach((item, index) => {
            orderMap.set(`${item.author}/${item.permlink}`, index);
          });

          return [...posts].sort((a, b) => {
            const indexA =
              orderMap.get(`${a.author}/${a.permlink}`) ?? Infinity;
            const indexB =
              orderMap.get(`${b.author}/${b.permlink}`) ?? Infinity;
            return indexA - indexB;
          });
        }
      }
    }

    /**
     * Busca posts por IDs em lotes (max 50 por lote)
     */
    async function fetchPostsInBatches(stubs) {
      const batches = [];

      for (let i = 0; i < stubs.length; i += BATCH_SIZE) {
        batches.push(stubs.slice(i, i + BATCH_SIZE));
      }

      const allPosts = [];
      let completedBatches = 0;

      elements.progressContainer.classList.remove("hidden");

      for (const batch of batches) {
        try {
          const response = await fetch(API_POSTS_BY_IDS, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "application/json",
            },
            body: JSON.stringify({
              posts: batch.map((stub) => ({
                author: stub.author,
                permlink: stub.permlink,
              })),
              truncate: currentSearch.truncate,
            }),
          });

          if (!response.ok) {
            throw new Error(
              `HTTP ${response.status}: ${response.statusText}`
            );
          }

          const posts = await response.json();
          allPosts.push(...posts.filter(Boolean));

          completedBatches++;
          const progress = Math.round(
            (completedBatches / batches.length) * 100
          );
          elements.progressFill.style.width = `${progress}%`;
          elements.progressText.textContent = `Carregando posts: ${completedBatches}/${batches.length} lotes (${allPosts.length} posts)`;

          if (completedBatches < batches.length) {
            await new Promise((resolve) => setTimeout(resolve, 100));
          }
        } catch (error) {
          console.error("Erro ao buscar lote de posts:", error);
        }
      }

      elements.progressContainer.classList.add("hidden");
      return allPosts;
    }

    /**
     * Renderiza um post
     */
    function renderPost(post, isSimilar = false) {
      if (!post) return "";

      // Extrai imagem do corpo ou do json_metadata
      let image = firstImageFromBody(post.body || "");

      let meta2;
      try {
        meta2 =
          typeof post.json_metadata === "string"
            ? JSON.parse(post.json_metadata)
            : post.json_metadata;
      } catch {}

      if (meta2?.image?.length > 0) {
        image = meta2.image[0];
      }

      if (image) {
        // Usa o proxy de imagens do Hive
        image = `https://images.hive.blog/200x0/${image}`;
      }

      const snippet = post.body
        ? post.body.slice(0, currentSearch.truncate) +
          (post.body.length > currentSearch.truncate ? "‚Ä¶" : "")
        : "";

      const fullDate = formatFullDate(post.created || post.updated || "");
      const displayDate = formatDate(post.created || post.updated || "");

      // Extrai tags do json_metadata para exibi√ß√£o
      let tags = [];
      if (post.json_metadata) {
        try {
          const metadata =
            typeof post.json_metadata === "string"
              ? JSON.parse(post.json_metadata)
              : post.json_metadata;

          if (metadata.tags && Array.isArray(metadata.tags)) {
            tags = metadata.tags.slice(0, 5); // Limita a 5 tags para exibi√ß√£o
          }
        } catch (e) {
          // Ignora erros de parse
        }
      }

      return `
        <article class="bg-white p-4 rounded-xl shadow-sm border border-slate-100 hover:shadow-md transition-shadow">
          ${
            isSimilar
              ? `
          <div class="mb-2">
            <span class="similar-post-badge px-3 py-1 rounded-full text-xs font-bold">
              üîó Post similar
            </span>
          </div>
          `
              : ""
          }
          
          <div class="flex flex-col md:flex-row gap-4">
            <div class="md:w-32 flex-shrink-0">
              ${
                image
                  ? `<img src="${image}" alt="thumb" class="h-32 w-full md:w-32 object-cover rounded-md" loading="lazy">`
                  : `<div class="h-32 w-full md:w-32 rounded-md bg-gradient-to-br from-slate-100 to-slate-200 flex items-center justify-center text-slate-400">
                    Sem imagem
                  </div>`
              }
            </div>
            <div class="flex-1 min-w-0">
              <div class="flex flex-col md:flex-row md:items-baseline justify-between gap-2">
                <h2 class="font-semibold text-lg leading-tight truncate">
                  ${escapeHtml(post.title || post.permlink || "(sem t√≠tulo)")}
                </h2>
                <div class="text-xs text-slate-500 whitespace-nowrap" title="${fullDate}">
                  ${displayDate}
                  ${currentSearch.sortOrder === "recent" ? " üìÖ" : ""}
                </div>
              </div>
              <div class="mt-1 text-sm text-slate-600">
                por <span class="font-medium">${escapeHtml(
                  post.author || "‚Äî"
                )}</span> ‚Ä¢ 
                Payout: ${formatPayout(
                  post.payout || post.pending_payout_value
                )} HIVE
              </div>
              <p class="mt-3 text-slate-700 text-sm whitespace-pre-line">
                ${escapeHtml(snippet)}
              </p>
              <div class="mt-4 flex flex-wrap gap-3 text-xs text-slate-500 items-center">
                <span class="px-2 py-1 bg-slate-100 rounded">üëÅÔ∏è ${
                  post.net_votes || 0
                } votos</span>
                <span class="px-2 py-1 bg-slate-100 rounded">üí¨ ${
                  post.children || post.replies?.length || 0
                } coment√°rios</span>
                <span class="px-2 py-1 bg-slate-100 rounded">üîÑ ${
                  post.reblogs || 0
                } reblogs</span>
                <span class="px-2 py-1 bg-slate-100 rounded">üè∑Ô∏è ${escapeHtml(
                  post.category || "‚Äî"
                )}</span>
                ${
                  tags.length > 0
                    ? `
                <div class="flex flex-wrap gap-1">
                  ${tags
                    .map(
                      (tag) => `
                    <span class="px-2 py-1 bg-blue-50 text-blue-600 rounded">${escapeHtml(
                      tag
                    )}</span>
                  `
                    )
                    .join("")}
                </div>
                `
                    : ""
                }
                <div class="ml-auto flex gap-2">
                  <span class="px-2 py-1 bg-blue-50 text-blue-600 rounded">
                    ${
                      currentSearch.sortOrder === "recent"
                        ? "Recente"
                        : "Relevante"
                    }
                  </span>
                  <a href="https://hive.blog${post.url || ""}" target="_blank" 
                     class="px-3 py-1 bg-slate-800 text-white rounded hover:bg-slate-700 transition-colors">
                    Abrir no Hive
                  </a>
                </div>
              </div>
            </div>
          </div>
        </article>
      `;
    }

    function updatePagination() {
      if (
        !currentSearch.isFetchingComplete ||
        currentSearch.filteredPosts.length === 0
      ) {
        elements.paginationEl.classList.add("hidden");
        return;
      }

      const totalPages = Math.ceil(
        currentSearch.filteredPosts.length / POSTS_PER_PAGE
      );
      const currentPage = currentSearch.currentPage;

      let pageInfo = `P√°gina ${currentPage} de ${totalPages} ‚Ä¢ ${currentSearch.filteredPosts.length} resultados`;

      if (currentSearch.searchMode === "similar") {
        pageInfo += ` ‚Ä¢ Posts similares`;
      }

      // Adiciona informa√ß√£o sobre filtros
      if (currentSearch.filters.authors.length > 0) {
        pageInfo += ` ‚Ä¢ Apenas autores: ${currentSearch.filters.authors
          .map((a) => `@${a}`)
          .join(", ")}`;
      }
      if (currentSearch.filters.includeTerms.length > 0) {
        pageInfo += ` ‚Ä¢ Inclui: ${currentSearch.filters.includeTerms
          .map((t) => `+${t}`)
          .join(", ")}`;
      }
      if (currentSearch.filters.excludeTerms.length > 0) {
        pageInfo += ` ‚Ä¢ Exclui: ${currentSearch.filters.excludeTerms
          .map((t) => `-${t}`)
          .join(", ")}`;
      }

      pageInfo += ` ‚Ä¢ Ordena√ß√£o: ${
        currentSearch.sortOrder === "recent" ? "Most recent" : "Relevance"
      }`;

      elements.pageInfo.textContent = pageInfo;

      elements.prevBtn.disabled = currentPage <= 1;
      elements.nextBtn.disabled = currentPage >= totalPages;

      elements.pageNumbers.innerHTML = "";

      const maxVisiblePages = 5;
      let startPage = Math.max(
        1,
        currentPage - Math.floor(maxVisiblePages / 2)
      );
      let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);

      if (endPage - startPage + 1 < maxVisiblePages) {
        startPage = Math.max(1, endPage - maxVisiblePages + 1);
      }

      for (let i = startPage; i <= endPage; i++) {
        const pageBtn = document.createElement("button");
        pageBtn.className = `min-w-8 h-8 px-2 rounded-lg ${
          i === currentPage
            ? "bg-slate-800 text-white"
            : "bg-slate-100 text-slate-700 hover:bg-slate-200"
        }`;
        pageBtn.textContent = i;
        pageBtn.addEventListener("click", () => goToPage(i));
        elements.pageNumbers.appendChild(pageBtn);
      }

      elements.paginationEl.classList.toggle("hidden", totalPages <= 1);
    }

    function renderCurrentPage() {
      if (
        !currentSearch.isFetchingComplete ||
        currentSearch.filteredPosts.length === 0
      ) {
        if (
          currentSearch.isFetchingComplete &&
          currentSearch.allPosts.length > 0
        ) {
          // H√° posts mas nenhum passou nos filtros
          elements.resultsEl.innerHTML = `
            <div class="p-8 text-center text-slate-500">
              <div class="text-4xl mb-2">üîç</div>
              <p class="text-lg">Nenhum post encontrado com os filtros aplicados.</p>
              <p class="text-sm mt-2">Tente ajustar os filtros ou limpar alguns deles.</p>
            </div>
          `;
        } else {
          elements.resultsEl.innerHTML = "";
        }
        return;
      }

      const sortedPosts = sortPosts(currentSearch.filteredPosts);

      const startIndex = (currentSearch.currentPage - 1) * POSTS_PER_PAGE;
      const endIndex = startIndex + POSTS_PER_PAGE;

      const pagePosts = sortedPosts.slice(startIndex, endIndex);

      elements.resultsEl.innerHTML = pagePosts
        .map((post) =>
          renderPost(post, currentSearch.searchMode === "similar")
        )
        .join("");

      if (pagePosts.length === 0) {
        elements.resultsEl.innerHTML = `
          <div class="p-8 text-center text-slate-500">
            <div class="text-4xl mb-2">üòï</div>
            <p class="text-lg">Nenhum post encontrado nesta p√°gina.</p>
          </div>
        `;
      }
    }

    function goToPage(page) {
      if (!currentSearch.isFetchingComplete) return;

      const totalPages = Math.ceil(
        currentSearch.filteredPosts.length / POSTS_PER_PAGE
      );
      if (page < 1 || page > totalPages) {
        return;
      }

      currentSearch.currentPage = page;
      renderCurrentPage();
      updatePagination();
      window.scrollTo({
        top: elements.resultsEl.offsetTop - 100,
        behavior: "smooth",
      });
    }

    /**
     * Executa busca por posts similares
     */
    async function doSimilarPostsSearch(url, truncate = 200) {
      const urlInfo = extractAuthorAndPermlinkFromURL(url);
      if (!urlInfo) {
        elements.metaEl.textContent =
          "URL inv√°lida. Use um link do Hive (hive.blog, ecency.com, peakd.com, etc.)";
        return;
      }

      setLoading(true);
      elements.resultsEl.innerHTML = "";
      elements.metaEl.textContent = `Buscando posts similares a @${urlInfo.author}/${urlInfo.permlink}...`;
      elements.paginationEl.classList.add("hidden");
      elements.originalPostInfo.classList.add("hidden");
      updateSortButtons();

      try {
        // Primeiro, busca o post original para mostrar informa√ß√µes
        const originalPostResponse = await fetch(API_POSTS_BY_IDS, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Accept: "application/json",
          },
          body: JSON.stringify({
            posts: [
              {
                author: urlInfo.author,
                permlink: urlInfo.permlink,
              },
            ],
            truncate: truncate,
          }),
        });

        if (originalPostResponse.ok) {
          const originalPosts = await originalPostResponse.json();
          if (originalPosts && originalPosts.length > 0) {
            currentSearch.originalPost = originalPosts[0];
            updateOriginalPostInfo();
          }
        }

        // Agora busca posts similares
        elements.metaEl.textContent = `Buscando posts similares a @${urlInfo.author}/${urlInfo.permlink}...`;
        const similarPosts = await fetchSimilarPosts(
          urlInfo.author,
          urlInfo.permlink,
          truncate
        );

        if (!similarPosts || similarPosts.length === 0) {
          elements.metaEl.textContent = "Nenhum post similar encontrado.";
          elements.resultsEl.innerHTML = `
            <div class="p-8 text-center text-slate-500">
              <div class="text-4xl mb-2">üîç</div>
              <p class="text-lg">Nenhum post similar encontrado para este post.</p>
              <p class="text-sm mt-2">Tente buscar por palavras-chave relacionadas.</p>
            </div>
          `;
          return;
        }

        // Extrai os stubs (author, permlink) dos posts similares
        const stubs = similarPosts.map((item) => ({
          author: item.author,
          permlink: item.permlink,
        }));

        // Armazena os stubs para manter a ordem original
        currentSearch.similarPostsStubs = stubs;

        // Busca os detalhes completos de todos os posts similares em lotes
        elements.metaEl.textContent = `Encontrados ${stubs.length} posts similares. Carregando detalhes...`;
        const allPosts = await fetchPostsInBatches(stubs);

        // Atualiza estado
        currentSearch.searchMode = "similar";
        currentSearch.allPosts = allPosts;
        currentSearch.filteredPosts = [...allPosts]; // Inicialmente, todos os posts
        currentSearch.isFetchingComplete = true;
        currentSearch.currentPage = 1;

        // Aplica filtros (se houver)
        applyFilters();

        // Renderiza primeira p√°gina
        renderCurrentPage();
        updatePagination();

        elements.metaEl.textContent = `Found ${
          allPosts.length
        } Similar posts ‚Ä¢ Sorting: ${
          currentSearch.sortOrder === "recent" ? "Most recent" : "Relevance"
        }`;
      } catch (error) {
        console.error("Error searching for similar posts:", error);
        elements.metaEl.innerHTML = `<span class="text-red-600">Erro na busca: ${error.message}</span>`;
        elements.resultsEl.innerHTML = `
          <div class="p-4 text-red-600 bg-red-50 rounded-lg">
            Failed to find similar posts. Please check that the link is correct and try again.
          </div>
        `;
      } finally {
        setLoading(false);
      }
    }

    /**
     * Executa busca normal (n√£o por link)
     */
    async function doNormalSearch(q, truncate = 200) {
      // Extrai filtros da query
      const { cleanQuery, filters } = extractFiltersFromQuery(q);

      // Atualiza estado
      currentSearch.searchMode = "normal";
      currentSearch.originalPost = null;
      currentSearch.similarPostsStubs = [];
      currentSearch.query = q;
      currentSearch.cleanQuery = cleanQuery;
      currentSearch.truncate = truncate;
      currentSearch.sortOrder = "relevance";
      currentSearch.allPosts = [];
      currentSearch.filteredPosts = [];
      currentSearch.currentPage = 1;
      currentSearch.totalResults = 0;
      currentSearch.isFetchingComplete = false;
      currentSearch.originalSearchResults = [];
      currentSearch.filters = filters;

      setLoading(true);
      elements.resultsEl.innerHTML = "";
      elements.metaEl.textContent = "Buscando...";
      elements.paginationEl.classList.add("hidden");
      elements.originalPostInfo.classList.add("hidden");
      updateSortButtons();
      updateActiveFiltersDisplay();

      // Se n√£o h√° query ap√≥s remover filtros
      if (!cleanQuery && filters.authors.length === 0) {
        setLoading(false);
        elements.metaEl.textContent =
          "Digite uma pesquisa ou use @autor para buscar posts de um autor espec√≠fico";
        return;
      }

      try {
        const searchQuery = cleanQuery;

        const params = new URLSearchParams({
          q: searchQuery,
          truncate: String(truncate),
          result_limit: String(MAX_RESULTS),
          full_posts: "0",
        });

        const response = await fetch(`${API_BASE}?${params}`);

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        const results = Array.isArray(data) ? data : data.results || [];

        if (results.length === 0) {
          elements.metaEl.textContent = "Nenhum resultado encontrado.";
          if (filters.authors.length > 0) {
            elements.metaEl.textContent += ` Nenhum post encontrado para os autores: ${filters.authors
              .map((a) => `@${a}`)
              .join(", ")}`;
          }
          elements.resultsEl.innerHTML = `
            <div class="p-8 text-center text-slate-500">
              <div class="text-4xl mb-2">üîç</div>
              <p class="text-lg">Nenhum resultado encontrado para "${escapeHtml(
                q
              )}".</p>
              ${
                filters.authors.length > 0
                  ? `<p class="text-sm mt-2">Procurando por autores: ${filters.authors
                      .map((a) => `@${a}`)
                      .join(", ")}</p>`
                  : ""
              }
            </div>
          `;
          return;
        }

        currentSearch.originalSearchResults = results;
        currentSearch.totalResults = results.length;

        let metaText = `Found ${results.length} resultados`;
        if (filters.authors.length > 0) {
          metaText += `. Filtrando por autores: ${filters.authors
            .map((a) => `@${a}`)
            .join(", ")}`;
        }
        if (filters.includeTerms.length > 0) {
          metaText += `. Incluindo termos: ${filters.includeTerms
            .map((t) => `+${t}`)
            .join(", ")}`;
        }
        if (filters.excludeTerms.length > 0) {
          metaText += `. Excluindo termos: ${filters.excludeTerms
            .map((t) => `-${t}`)
            .join(", ")}`;
        }
        metaText += `. Carregando detalhes...`;
        elements.metaEl.textContent = metaText;

        const stubs = results.map((item) => ({
          author: item.author,
          permlink: item.permlink,
        }));

        const allPosts = await fetchPostsInBatches(stubs);

        currentSearch.allPosts = allPosts;
        currentSearch.isFetchingComplete = true;

        // Aplica filtros
        applyFilters();

        // Renderiza primeira p√°gina
        renderCurrentPage();
        updatePagination();

        // Atualiza meta informa√ß√µes
        let finalMetaText = `Carregados ${allPosts.length} posts`;
        if (currentSearch.filteredPosts.length !== allPosts.length) {
          finalMetaText += ` ‚Ä¢ ${currentSearch.filteredPosts.length} after filters`;
        }
        finalMetaText += ` ‚Ä¢ Ordena√ß√£o: ${
          currentSearch.sortOrder === "recent" ? "Most recent" : "Relevance"
        }`;

        elements.metaEl.textContent = finalMetaText;
      } catch (error) {
        console.error("Erro na busca:", error);
        elements.metaEl.innerHTML = `<span class="text-red-600">Erro na busca: ${error.message}</span>`;
        elements.resultsEl.innerHTML = `
          <div class="p-4 text-red-600 bg-red-50 rounded-lg">
            Falha ao buscar resultados. Verifique sua conex√£o e tente novamente.
          </div>
        `;
      } finally {
        setLoading(false);
      }
    }

    /**
     * Executa a busca principal
     */
    async function doSearch(q, truncate = 200) {
      // Verifica se √© uma URL do Hive
      const urlInfo = isHiveURL(q);
      if (urlInfo.isHiveURL) {
        await doSimilarPostsSearch(q, truncate);
      } else {
        await doNormalSearch(q, truncate);
      }
    }

    function toggleSortOrder(newSortOrder) {
      if (
        currentSearch.sortOrder === newSortOrder ||
        !currentSearch.isFetchingComplete
      )
        return;

      currentSearch.sortOrder = newSortOrder;
      currentSearch.currentPage = 1;

      updateSortButtons();
      renderCurrentPage();
      updatePagination();

      let metaText = `Carregados ${currentSearch.allPosts.length} posts`;
      if (currentSearch.searchMode === "similar") {
        metaText = `Found ${currentSearch.allPosts.length} posts similar`;
      } else if (
        currentSearch.filteredPosts.length !== currentSearch.allPosts.length
      ) {
        metaText += ` ‚Ä¢ ${currentSearch.filteredPosts.length} after filters`;
      }
      metaText += ` ‚Ä¢ Ordena√ß√£o: ${
        currentSearch.sortOrder === "recent" ? "Most recent" : "Relevance"
      }`;

      elements.metaEl.textContent = metaText;
    }

    /**
     * Limpa todos os filtros
     */
    function clearAllFilters() {
      currentSearch.filters = {
        authors: [],
        includeTerms: [],
        excludeTerms: [],
      };

      elements.searchInput.value = currentSearch.cleanQuery;
      updateActiveFiltersDisplay();

      // Reaplica filtros (que agora est√£o vazios)
      applyFilters();
      currentSearch.currentPage = 1;
      renderCurrentPage();
      updatePagination();
    }

    // Event Listeners
    elements.searchForm.addEventListener("submit", (e) => {
      e.preventDefault();
      const q = elements.searchInput.value.trim();
      const truncate = Number(elements.truncateSelect.value) || 200;

      if (!q) {
        alert("Digite um termo para buscar ou cole um link do Hive");
        return;
      }

      doSearch(q, truncate);
    });

    elements.sortRelevance.addEventListener("click", () => {
      toggleSortOrder("relevance");
    });

    elements.sortRecent.addEventListener("click", () => {
      toggleSortOrder("recent");
    });

    elements.clearFilters.addEventListener("click", clearAllFilters);

    elements.closeOriginalPostInfo.addEventListener("click", () => {
      elements.originalPostInfo.classList.add("hidden");
    });

    elements.prevBtn.addEventListener("click", () =>
      goToPage(currentSearch.currentPage - 1)
    );
    elements.nextBtn.addEventListener("click", () =>
      goToPage(currentSearch.currentPage + 1)
    );

    // Placeholder com exemplos
    elements.searchInput.placeholder =
      "Ex: @sm-silva anime +life -comics ou URL do post Hive";

    // Busca inicial
    window.addEventListener("DOMContentLoaded", () => {
      const q = elements.searchInput.value.trim();
      const truncate = Number(elements.truncateSelect.value) || 200;
      doSearch(q, truncate);
    });
  </script>
</body>
</html>
